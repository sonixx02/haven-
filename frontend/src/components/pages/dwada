import React, { useEffect, useRef, useState } from "react";

const HereMaps = () => {
  const mapRef = useRef(null);
  const [userLocation, setUserLocation] = useState(null);
  const [destination, setDestination] = useState("");
  const [map, setMap] = useState(null);
  const [userMarker, setUserMarker] = useState(null);
  const [destMarker, setDestMarker] = useState(null);
  const [routes, setRoutes] = useState([]); // State to store routes
  const [selectedRouteIndex, setSelectedRouteIndex] = useState(null); // State for selected route
  const [navigationInstructions, setNavigationInstructions] = useState([]); // State for navigation instructions
  const HERE_API_KEY = "mMN6QckgeTEUXfQPmWvFOKgr9AiuefC4AZ8Lj-OGUJg"; // Replace with your actual API key

  


  useEffect(() => {
    // Load the HERE Maps script
    const script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://js.api.here.com/v3/3.1/mapsjs-core.js";
    script.async = true;
    document.body.appendChild(script);

    script.onload = () => {
      const script2 = document.createElement("script");
      script2.type = "text/javascript";
      script2.src = "https://js.api.here.com/v3/3.1/mapsjs-service.js";
      script2.async = true;
      document.body.appendChild(script2);

      script2.onload = () => {
        const script3 = document.createElement("script");
        script3.type = "text/javascript";
        script3.src = "https://js.api.here.com/v3/3.1/mapsjs-mapevents.js";
        script3.async = true;
        document.body.appendChild(script3);

        script3.onload = initMap;

        
      };
    };

    return () => {
      // Clean up scripts when component unmounts
      document.body.removeChild(script);
    };
  }, []);

  const initMap = () => {
    // Initialize the platform object
    const platform = new window.H.service.Platform({
      apikey: HERE_API_KEY, // Replace with your actual API key
    });

    // Obtain the default map types from the platform object
    const defaultLayers = platform.createDefaultLayers();

    // Instantiate the map
    const newMap = new window.H.Map(
      mapRef.current,
      defaultLayers.vector.normal.map,
      {
        center: { lat: 19.076, lng: 72.8777 }, // Mumbai coordinates
        zoom: 7,
        pixelRatio: window.devicePixelRatio || 1,
      }
    );

    // Create the behaviors
    const behavior = new window.H.mapevents.Behavior(
      new window.H.mapevents.MapEvents(newMap)
    );

    setMap(newMap);

    // Get user's current location
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const { latitude, longitude } = position.coords;
        setUserLocation({ lat: latitude, lng: longitude });
        console.log(`User location: ${latitude}, ${longitude}`);

        // Log user location to backend
        fetch("/api/log-location", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ latitude, longitude }),
        });

        // Add a marker for user location
        const marker = new window.H.map.Marker({
          lat: latitude,
          lng: longitude,
        });
        newMap.addObject(marker);
        setUserMarker(marker);

        // Center the map on user's location
        newMap.setCenter({ lat: latitude, lng: longitude });
      },
      (error) => {
        console.error("Error getting location:", error);
      }
    );
  };

  const handleDestinationSubmit = async (e) => {
    e.preventDefault();
    try {
      const response = await fetch(
        "http://localhost:3001/api/get-destination",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ destination }),
        }
      );

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      if (data.latitude && data.longitude) {
        console.log(`Destination: ${destination}`);
        console.log(
          `Destination coordinates: ${data.latitude}, ${data.longitude}`
        );

        // Remove previous route objects and markers
        map.removeObjects(map.getObjects());

        // Add markers for origin and destination
        const originMarker = new window.H.map.Marker(userLocation);
        const destMarker = new window.H.map.Marker({
          lat: data.latitude,
          lng: data.longitude,
        });
        map.addObjects([originMarker, destMarker]);

        // Calculate and display multiple routes
        calculateAndDisplayRoutes(userLocation, {
          lat: data.latitude,
          lng: data.longitude,
        });
      } else {
        console.log("Destination not found");
      }
    } catch (error) {
      console.error("Error fetching destination coordinates:", error);
      // You might want to show this error to the user in some way
    }
  };

  const calculateAndDisplayRoutes = (origin, destination) => {
    const platform = new window.H.service.Platform({
      apikey: HERE_API_KEY,
    });

    const router = platform.getRoutingService(null, 8);
    const routeRequestParams = {
      routingMode: "fast",
      transportMode: "car",
      origin: `${origin.lat},${origin.lng}`,
      destination: `${destination.lat},${destination.lng}`,
      alternatives: 3, // Request up to 3 alternative routes
      return: "polyline,turnByTurnActions,actions,instructions,travelSummary",
    };

    router.calculateRoute(routeRequestParams, onSuccess, onError);
  };

  const onSuccess = (result) => {
    console.log("Route calculation result:", result);
    if (result.routes && result.routes.length > 0) {
      // Store routes in state
      setRoutes(result.routes);

      // Clear previous route markers from the map
      map.removeObjects(
        map.getObjects().filter((obj) => !(obj instanceof window.H.map.Marker))
      );

      // Add routes to the map
      result.routes.forEach((route, index) => {
        addRouteShapeToMap(route, getRouteColor(index));
      });

      // Zoom to fit all routes
      map.getViewModel().setLookAtData({
        bounds: map.getObjects().reduce((bbox, obj) => {
          return bbox
            ? bbox.mergeLatLngBounds(obj.getBoundingBox())
            : obj.getBoundingBox();
        }, null),
      });
    } else {
      console.error("No routes found in the result");
    }
  };

  const onError = (error) => {
    console.error("Error calculating routes:", error);
    alert("Can't calculate routes. Please try again.");
  };

  const addRouteShapeToMap = (route, color) => {
    if (route && route.sections) {
      route.sections.forEach((section) => {
        if (section.polyline) {
          let linestring = H.geo.LineString.fromFlexiblePolyline(
            section.polyline
          );
          let polyline = new window.H.map.Polyline(linestring, {
            style: {
              lineWidth: 6, // Increased line width for better visibility
              strokeColor: color,
            },
          });
          map.addObject(polyline);
        }
      });
    } else {
      console.error("Invalid route object:", route);
    }
  };

  const getRouteColor = (index) => {
    const colors = [
      "rgba(0, 100, 0, 0.8)", // Dark Green for safest route
      "rgba(139, 0, 0, 0.8)", // Dark Red for less safe route
      "rgba(0, 0, 139, 0.8)", // Dark Blue for alternate routes
      "rgba(184, 134, 11, 0.8)", // Dark Goldenrod for alternate routes
    ];
    return colors[index % colors.length];
  };

  // Function to handle route selection
  const handleRouteSelection = (index) => {
    // Remove all objects that are not markers from the map (clearing routes)
    map.removeObjects(
      map.getObjects().filter((obj) => !(obj instanceof window.H.map.Marker))
    );

    // Add the selected route to the map
    const selectedRoute = routes[index];
    addRouteShapeToMap(selectedRoute, getRouteColor(index));

    // Populate navigation instructions for the selected route
    setSelectedRouteIndex(index);

    // Ensure correct instructions are mapped
    const instructions = selectedRoute.sections.flatMap(
      (section) => section.actions
    );
    setNavigationInstructions(instructions);

    // Zoom to fit the selected route on the map
    map.getViewModel().setLookAtData({
      bounds: selectedRoute.sections.reduce((bbox, section) => {
        const sectionLine = window.H.geo.LineString.fromFlexiblePolyline(
          section.polyline
        );
        const sectionBBox = sectionLine.getBoundingBox();
        return bbox ? bbox.mergeLatLngBounds(sectionBBox) : sectionBBox;
      }, null),
    });
  };

  return (
    <div className="flex">
      {/* Left Panel */}
      <div className="w-[40%] h-screen p-6 overflow-y-auto">
        <h2 className="text-2xl font-bold mb-4">Your Location</h2>
        {userLocation ? (
          <div>
            <p>Latitude: {userLocation.lat}</p>
            <p>Longitude: {userLocation.lng}</p>
          </div>
        ) : (
          <p>Loading your location...</p>
        )}
        <form
          onSubmit={handleDestinationSubmit}
          className="bg-white shadow-md rounded-lg p-6"
        >
          <h3 className="text-xl font-bold mb-4">Destination</h3>
          <input
            type="text"
            value={destination}
            onChange={(e) => setDestination(e.target.value)}
            placeholder="Enter destination"
            className="w-full p-2 border border-gray-300 rounded mb-4"
            required
          />
          <button
            type="submit"
            className="bg-blue-500 text-white py-2 px-4 rounded hover:bg-blue-600"
          >
            Get Route
          </button>
        </form>
        {routes.length > 0 && (
          <div className="mt-4">
            <h3 className="text-xl font-bold mb-2">Available Routes</h3>
            <p className="mb-2">
              Routes are color-coded based on their safety levels:
              <span className="text-green-600 ml-1">Green = Safest</span>,
              <span className="text-red-600 ml-1">Red = Less Safe</span>,
              <span className="text-blue-600 ml-1">Blue = Alternate</span>,
              <span className="text-yellow-600 ml-1">
                Goldenrod = Alternate
              </span>
              .
            </p>
            <ul>
              {routes.map((route, index) => {
                // Determine route safety message and color
                let safetyMessage = "";
                let textColor = "";

                if (index === 0) {
                  safetyMessage = "This route is the safest (green).";
                  textColor = "text-green-600"; // Dark Green for safest route
                } else if (index === 1) {
                  safetyMessage = "This route is moderately safe (blue).";
                  textColor = "text-blue-600"; // Dark Blue for moderately safe route
                } else if (index === 2) {
                  safetyMessage = "This route is less safe (dark golden).";
                  textColor = "text-yellow-700"; // Dark Goldenrod for alternate routes
                } else {
                  safetyMessage = "This route is not as safe (red).";
                  textColor = "text-red-600"; // Dark Red for less safe route
                }

                return (
                  <li key={index} className="mb-2">
                    <button
                      onClick={() => handleRouteSelection(index)}
                      className={`text-blue-500 hover:underline ${
                        index === 0 ? "font-bold" : ""
                      }`}
                    >
                      Route {index + 1}
                    </button>
                    <span className={`ml-2 text-sm ${textColor}`}>
                      {safetyMessage}
                    </span>
                  </li>
                );
              })}
            </ul>
          </div>
        )}

        {/* Navigation Instructions Card */}
        {selectedRouteIndex !== null && (
          <div className="mt-4 bg-white shadow-md rounded-lg p-4 max-h-60 overflow-y-scroll">
            <h3 className="text-xl font-bold mb-2">Navigation Instructions</h3>
            <ul>
              {navigationInstructions.map((action, index) => (
                <li key={index} className="mb-2">
                  {action.instruction}
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>

      {/* Right Map Section */}
      <div className="w-[60%] h-screen" ref={mapRef}></div>
    </div>
  );
};

export default HereMaps;
